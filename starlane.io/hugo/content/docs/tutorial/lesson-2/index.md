---
title: "Lesson 2"
date: 2022-02-12T21:29:31-06:00
draft: false 
---

# LESSON 2 -- DEPLOY AN APP

The source code for this lesson can be found on github here:

[https://github.com/mechtronium/starlane/tree/main/tutorial/lesson-2/](https://github.com/mechtronium/starlane/tree/main/tutorial/lesson-2/)

## SETUP SCRIPTS

At the time of this writing Starlane does not persist changes.  In order to re-setup localhost and the repository you created in lesson 1 you will need to rerun the create commands--BUT there is a BETTER way! 

You can run a setup script located in the repository here `/tutorial/lesson-2/script/setup.script`.   The script looks like this:

```
? create localhost<Space>;
? create localhost:repo<Base<Repo>>;
? create localhost:repo:tutorial<ArtifactBundleSeries>;
```

The commands look familiar, but what is the `?` operator preceding the create command?  That is the **Ensure Strategy** operator which tells the script runner not to fail if the resource has already been created.  Using the Ensure Strategy operator means you can rerun this script multiple times without getting a failure.

## APPS & MECHTRONS
You may have already learned that Starlane can execute WebAssembly code that implements the Mechtron framework creating, when deployed, you guessed it: A Mechtron resource!  So what is an App?  Well, the answer is that an App IS technically a Mechtron with some special responsibilities and privileges.  The main difference is that a Mechtron must be a member of an App however an App can be standalone or be composed of many Mechtrons.  


## THE APP
In this tutorial we are just deploying a prebuilt App, not coding it, however it does help to look at and understand what the code is doing:

### CODE

```rust

//! mechtron_init() is called after the Wasm file has been compiled by Starlane.
//! It's most important job is to register any mechtron factories.
#[no_mangle]
pub extern "C" fn mechtron_init()
{
    //! Here we register the MyAppFactory for creating 'my-app' Mechtrons
    mechtron_register(Box::new(MyAppFactory::new()));
}

//! Factory implementation for MyApp Mechtron
pub struct MyAppFactory { }

impl MyAppFactory {
    pub fn new() -> Self {
        Self{}
    }
}

impl MechtronFactory for MyAppFactory {

    //! Here we returning the very important Mechtron name which will must be referenced in the App config
    fn mechtron_name(&self) -> String {
        "my-app".to_string()
    }

    fn create(&self, stub: ResourceStub) -> Result<Box<dyn Mechtron>, Error> {
        Ok(Box::new(MyApp::new()))
    }
}


//! MyApp mechtron is an implementation of the Mechtron trait.
//! It handles requests and produces Responses
pub struct MyApp {}

impl MyApp {
    pub fn new()->Self{
        Self{}
    }
}

impl Mechtron for MyApp  {

    //! Method for handling Http requests (other types of requests will result in an error response.
    //! Here we are just responding 'Hello World!' to any request that comes in
    fn handle_http_request(&self, ctx: &dyn MechtronCtx, request: HttpRequest ) -> Result<ResponseCore,Error> {
        Ok(request.ok("Hello World!"))
    }

}
```

You can see an actual implementation of this App Mechtron code in **tutorial/lesson-2/wasm/my-app/src/lib.rs**


### APP CONFIG
Apps MUST have a config property set at all times, meaning you cannot simply create an app by issuing a *create localhost:my-app<App>* command.

Let's create the App config and package it up in a bundle for deployment:

```
App {

  Set {
    +wasm.src=$(self.config.bundle):/wasm/my-app.wasm,
    +mechtron.name=my-app,
  }

}
```

You can see that we are configuring an App and that we Set two important app properties: wasm.src and mechtron.name... BOTH are absolutly required for an App or Mechtron to work at all.

Wasm src is the binary Wasm file generated by the compiler (which we will later package in the ArtifactBundle).   You may notice that wasm.src has an interesting substitution *$(self.config.bundle)* which is telling starlane to replace that portion of the address with the address of the bundle where the config came from (which in this case is *localhost:repo:tutorial:2.0.0*. The advantage to using a substitution is that now this config can be installed in a completely different location.

mechtron.name references the same name that is bound to the Mechtron Factory registered in the *mechtron_init* method of the code... it's important because a single Wasm implementation is able to serve multiple types of Mechtrons which saves a lot on resources.

### BIND
Like the localhost space we need to create a bind for the App to tell it how to process incoming requests.  Here is our bind file:

```
Bind {

  Http {

    <Get>/index.html -> {{ }} => &;

  }

}
```

Of course you can see a new type of Pipeline Stop `{{ }}`. This is called an Internal and tells the pipeline to send the request to the Internal portion of the Resource in this case the request will be handled by the Mechtron code.


### MAKE
Let's execute the Makefile in tutorial/lesson-2 which will compile our Mechtron code and package it and the configuration in a bundle.zip:

```bash
make all
```

### PUBLISH
Now we run the familiar publish command, but this time we publish to version 2.0.0 ArtifactBundle (since this is lesson 2):

```bash
starlane exec "publish ^[ bundle.zip ]-> localhost:repo:tutorial:2.0.0"
```

### CREATE THE APP
Now that the config and bind are present in an ArtifactBundle we can now create our app:

```bash
starlane exec "create localhost:my-app<App>{ +config=localhost:repo:tutorial:2.0.0:/config/my-app.app,
                                             +bind=localhost:repo:tutorial:2.0.0:/bind/app.bind }"
```

So we can see that we are mounting the App at address location *localhost:my-app* and we can append the exact same property setting syntax to the end of the create command specifying to set the config and bind properties respectively.

### UPDATING THE LOCALHOST SPACE BIND

The App should be running but there is presently no way to reach it. So let's update the localhost bind so it has a proper endpoint:

```
Bind {

  Http {

    <Get>/app/ -> localhost:my-app^Http<Get>/index.html => &;
    <Get>/(.*) -> localhost:repo:tutorial:2.0.0:/html/$1 => &;

  }

}
```


Importantly we have put our route to the app first, since the request will follow the first pattern match that it finds and the pattern for the static site will match any path.

Notice that instead of grabbing the Apps state (which we cannot do since Apps are stateless) we are instead instructing the Pipeline to convert the request to something specific

```
    address        convert request
|------^-------||--------^----------|
localhost:my-app^Http<Get>/index.html
```

You may have noticed that the Mechtron code itself doesn't care what the path or method is it will actually return 'Hello World!' no matter what it receives.  This example still illustrated the power of the bind and how it can rewrite requests multiple times.

The localhost.bind was already deployed in our previous publish so all we have to do is update localhost to use the new bind:

```bash
starlane exec "set localhost{ +bind=localhost:repo:tutorial:2.0.0:/bind/localhost.bind }"
```

Now point your browser to *http://localhost:8080/app/* and you should receive a nice "Hello World!" Message!

## SUMMARY
Congratulations! You have deployed your first App!  

Next we are going to learn how to create a dynamic app that processes a portion of the request path and returns a custom response.

[NEXT : CREATE AND DEPLOY A DYNAMIC APP ]({{< ref "/docs/tutorial/lesson-3" >}} "Lesson 3")

